/**
 * @author ksnavely
 *
 */
import java.math.BigInteger;

public class KJChessPawn extends KJChessPiece {
	/**
	 * @param colorChar
	 */
	public KJChessPawn(char colorChar) {
		super(colorChar);
        this.pieceChar = 'P';
       // if ( this.colorChar == 'W' ) {
        this.bitBoard = new BigInteger( "00000000" +
                                        "00000000" +
                                        "00000000" +
                                        "00000000" +
                                        "00000000" +
                                        "00000000" +
                                        "11111111" +
                                        "00000000", 2 );
        if (this.colorChar == 'B')
            this.bitBoard = this.flipBitBoard();
	}

    /* getAllowedMovesBitBoard()
     * Generate a bit board of allowed positions for the piece type.
     * For pawns:
     *  - Single row push
     *  - Double row push for pieces in the initial position (second row)
     *  - Diagonal captures (not implemented)
     *  - En passant (not implemented)
     */
    public BigInteger getAllowedMovesBitBoard() {
        // Generate the single row pawn push
        BigInteger allowed = this.bitBoard.shiftLeft(8);
        // Generate two row pawn push
        allowed = allowed.or( this.getTwoRowPawnPushBitBoard() );

        return allowed;
    }

    public BigInteger getTwoRowPawnPushBitBoard() {
        // Grab ONLY the second row of the bitBoard. If a pawn hasn't
        // moved it's bit is 1. Shift this only row up by two and or it
        // to the normal shifted allowe moves.
        BigInteger secondRow = new BigInteger( "00000000" +
                                               "00000000" +
                                               "00000000" +
                                               "00000000" +
                                               "00000000" +
                                               "00000000" +
                                               "11111111" +
                                               "00000000", 2 );
        return this.bitBoard.and( secondRow ).shiftLeft(16);
    }
    
    /* move (int shift)
     * "Move" a single piece using a shift int and altering the current bitboard.
     * Shift is a number 0-64 generated by KJChessBoard.getCoordShift(). When BigInteger 1
     * is left-shifted by shift, it generates the bitboard for the new position. The old
     * position of the individual piece (not piece type) must then be or'd with the 
     * moveBitBoard. In this way, the new pieces' bitboard may be generated with an xor
     * between the current and move bitboard.
     */
    public BigInteger move( int shift ) {
        // Generate a 1 bit at the new position
        BigInteger moveBitBoard = BigInteger.valueOf(1).shiftLeft( shift ); 

        Boolean twoRow = this.isTwoRowPawnPush( shift );
        if ( twoRow )
            moveBitBoard = moveBitBoard.or( BigInteger.valueOf(1).shiftLeft( shift - 16 ) );
        else // It was a one row push
            moveBitBoard = moveBitBoard.or( BigInteger.valueOf(1).shiftLeft( shift - 8 ) );

        this.bitBoard = this.bitBoard.xor( moveBitBoard );
        
		return this.bitBoard;
    }

    public Boolean isTwoRowPawnPush( int shift ) {
        // Check if the shift value is in the two-row pawn push move bit board
        // If it's in, there will be a 1 bit at the shift position. Else, it'll be zero.
        BigInteger twoRowPiece = BigInteger.valueOf(1).shiftLeft(shift).and( this.getTwoRowPawnPushBitBoard() );

        return !twoRowPiece.equals( BigInteger.valueOf(0) );

    }
}
